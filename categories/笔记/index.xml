<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>笔记 on 斑竹坡-程序员</title>
    <link>https://dev960.github.io/categories/%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 笔记 on 斑竹坡-程序员</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 14 Sep 2023 22:37:56 +0800</lastBuildDate><atom:link href="https://dev960.github.io/categories/%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>snort嗅探和hping3攻击配置</title>
      <link>https://dev960.github.io/post/snort%E5%97%85%E6%8E%A2%E5%92%8Chping3%E6%94%BB%E5%87%BB%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Thu, 14 Sep 2023 22:37:56 +0800</pubDate>
      
      <guid>https://dev960.github.io/post/snort%E5%97%85%E6%8E%A2%E5%92%8Chping3%E6%94%BB%E5%87%BB%E9%85%8D%E7%BD%AE/</guid>
      <description>$sudo apt install snort $sudo vim /etc/snort/ruls/local.rule $sudo sudo snort -c /etc/snort/snort.conf -i enp1s0 -A unsock -l /tmp/ -c 指定配置文件 -i 指定网卡 -A 指定报警类型 -l 指定socket unix路径，/tmp/snort_adlert   snort.conf-&amp;gt; local.rule
alert icmp any any -&amp;gt; $HOME_NET any (msg:&amp;#34;ICMP flood&amp;#34;; sid:1000001; rev:1; classtype:icmp-event; detection_filter:track by_dst, count 10, seconds 3;) alert tcp any any -&amp;gt; $HOME_NET any (flags: S; msg:&amp;#34;DoS Attack Type : SYNflood&amp;#34;; flow:stateless; sid:3; detection_filter:track by_dst, count 10, seconds 3;) alert udp $EXTERNAL_NET any -&amp;gt; $HOME_NET any (msg:&amp;#34;DDOS shaft agecondent to handler, Type: Udp flood&amp;#34;; content:&amp;#34;alive&amp;#34;; reference:arachnids,256; classtype:attempted-dos; sid:240; rev:2;)   hping3</description>
    </item>
    
    <item>
      <title>nginx离线安装(国产)</title>
      <link>https://dev960.github.io/post/nginx%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%9B%BD%E4%BA%A7/</link>
      <pubDate>Thu, 14 Sep 2023 21:37:56 +0800</pubDate>
      
      <guid>https://dev960.github.io/post/nginx%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%9B%BD%E4%BA%A7/</guid>
      <description>1. 依赖： wget https://nginx.org/download/nginx-1.20.2.tar.gz
wget https://buildpack.oss-cn-shanghai.aliyuncs.com/static/r6d/nginx/nginx-compile-lib/pcre-8.44.tar.gz tar xzf pcre-8.44.tar.gz
wget https://buildpack.oss-cn-shanghai.aliyuncs.com/static/r6d/nginx/nginx-compile-lib/zlib-1.2.11.tar.gz tar xzf zlib-1.2.11.tar.gz
wget https://buildpack.oss-cn-shanghai.aliyuncs.com/static/r6d/nginx/nginx-compile-lib/openssl-1.1.1l.tar.gz tar xzf openssl-1.1.1l.tar.gz
2. 安装步骤 cd /eflex/packages/env tar -xvf pcre-8.44.tar.gz cd /eflex/packages/env/pcre-8.44 ./configure make make install cd /eflex/packages/env tar -xvf openssl-1.1.1l.tar.gz cd /eflex/packages/env/openssl-1.1.1l ./config make make install cd /eflex/packages/env tar -xvf zlib-1.2.11.tar.gz cd /eflex/packages/env/zlib-1.2.11 ./config make make install 3. 编译： ./configure --prefix=/eflex/app/packages/nginx --with-http_ssl_module --with-openssl=../../env/openssl-1.1.1l --with-pcre=../../env/pcre-8.44 --with-zlib=../../env/zlib-1.2.11 4. 运行： $ make &amp;amp;&amp;amp; make install ./sbin/nginx -c .</description>
    </item>
    
    <item>
      <title>《给经理人的第一课》</title>
      <link>https://dev960.github.io/post/%E5%AE%89%E5%BE%B7%E9%B2%81%E6%A0%BC%E9%B2%81%E5%A4%AB%E7%BB%99%E7%BB%8F%E7%90%86%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E8%AF%BE/</link>
      <pubDate>Wed, 13 Sep 2023 21:37:56 +0800</pubDate>
      
      <guid>https://dev960.github.io/post/%E5%AE%89%E5%BE%B7%E9%B2%81%E6%A0%BC%E9%B2%81%E5%A4%AB%E7%BB%99%E7%BB%8F%E7%90%86%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E8%AF%BE/</guid>
      <description>“生产”包含什么？  你必须按预定的时间，可接受的品质以及可能的最低成本，一句顾客的需求制造及运送产品。
 找出决定整个生产流程的“限制步骤”，优化并行。以早餐店举列，限制步骤主要是煮鸡蛋，耗时，那么煮鸡蛋的时候，可以拿面包、烤面包、倒咖啡。
及早发现、及早解决
 所有的生产流程都有一个共通的特性，就是原料在流程中会变得越来越有价值。
生蛋的价值不如煮熟的蛋，搭配好在顾客面前才能实现其价值。因为顾客走进这家餐厅就是要享受它们。
 做项目也是同理，前期需求不明确，越到后期风险越大，最糟心的是重新设计推倒重来。记得新疆某项目，就是前期需求沟通不明确，导致发货以后，需求比预计的多且复杂，还牵涉到第三方运营商，最后烂尾。
我们做软硬件结合的产品，如果没有及早发现设备问题，到客户线程翻车，那是相当尴尬，等于让客户当小白鼠。
我们应该谨守“”及早发现、及早解决“的准则，如此我们便能生产流程中价值最低的阶段修正问题。
因此，我们应该在蛋商送蛋之前让他们把坏的蛋挑出来，而不是让我们的顾客在餐桌上发现它们。
同理，我们采购硬件设备的时候，应该让供应商进行测试，保证设备各零配件都正常工作。如果在”组装“好并发到公司后才发现有毛病，麻烦就大了，因为有可能无法交付给客户，耽误时间。
开发软件，也就是上线之前尽可能的多测试，把bug修复解决，不要到客户现场翻车。
从早餐店的库存谈起  我们不仅要辛勤工作，还得懂得如何工作。
 设定指标
  销售预测
  原料存货
  设备状况
  人力资源
  指标配对
 指标能将你的注意力引导到需要监督的事情上。
   指标清楚的列明了目标
  为评价管理活动提供了相当的客观性
  让在不通组织从事相同管理工作的人有相互比较的依据
  </description>
    </item>
    
    <item>
      <title>转linux 系统 UDP 丢包问题分析思路</title>
      <link>https://dev960.github.io/post/udp%E4%B8%A2%E5%8C%85%E6%8E%92%E6%9F%A5/</link>
      <pubDate>Wed, 13 Sep 2023 21:37:56 +0800</pubDate>
      
      <guid>https://dev960.github.io/post/udp%E4%B8%A2%E5%8C%85%E6%8E%92%E6%9F%A5/</guid>
      <description>linux 系统 UDP 丢包问题分析思路_ArthurKingYs的博客-CSDN博客
最近工作中遇到某个服务器应用程序 UDP 丢包，在排查过程中查阅了很多资料，总结出来这篇文章，供更多人参考。
在开始之前，我们先用一张图解释 linux 系统接收网络报文的过程。
 首先网络报文通过物理网线发送到网卡 网络驱动程序会把网络中的报文读出来放到 ring buffer 中，这个过程使用 DMA（Direct Memory Access），不需要 CPU 参与 内核从 ring buffer 中读取报文进行处理，执行 IP 和 TCP/UDP 层的逻辑，最后把报文放到应用程序的 socket buffer 中 应用程序从 socket buffer 中读取报文进行处理  在接收 UDP 报文的过程中，图中任何一个过程都可能会主动或者被动地把报文丢弃，因此丢包可能发生在网卡和驱动，也可能发生在系统和应用。
之所以没有分析发送数据流程，一是因为发送流程和接收类似，只是方向相反；另外发送流程报文丢失的概率比接收小，只有在应用程序发送的报文速率大于内核和网卡处理速率时才会发生。
本篇文章假定机器只有一个名字为 eth0 的 interface，如果有多个 interface 或者 interface 的名字不是 eth0，请按照实际情况进行分析。
NOTE：文中出现的 RX （receive） 表示接收报文， TX （transmit） 表示发送报文。
确认有 UDP 丢包发生 要查看网卡是否有丢包，可以使用 ethtool -S eth0 查看，在输出中查找 bad 或者 drop对应的字段是否有数据，在正常情况下，这些字段对应的数字应该都是 0。如果看到对应的数字在不断增长，就说明网卡有丢包。
另外一个查看网卡丢包数据的命令是 ifconfig ，它的输出中会有 RX (receive 接收报文)和 TX （transmit 发送报文）的统计数据：</description>
    </item>
    
    <item>
      <title>JVM内存占用和RES不匹配</title>
      <link>https://dev960.github.io/post/jvm%E5%86%85%E5%AD%98%E5%92%8Cres%E5%AE%9E%E9%99%85%E5%86%85%E5%AD%98%E4%B8%8D%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Tue, 12 Sep 2023 20:37:56 +0800</pubDate>
      
      <guid>https://dev960.github.io/post/jvm%E5%86%85%E5%AD%98%E5%92%8Cres%E5%AE%9E%E9%99%85%E5%86%85%E5%AD%98%E4%B8%8D%E5%8C%B9%E9%85%8D/</guid>
      <description>环境   SpringBooot项目
  Jar运行，参数：-Xms2g -Xmx2g
  Linux虚拟机运行内存8g
  启动占用18%左右
  接收文件分片，内存进行合并写磁盘
  top -p pid 内存占用飙升到30%左右，RES占用2.2g左右
  工具   jmap -histo pid 打印每个class的实例数目
  jmap -heap pid 查看概要信息
  jmap -dump:format=b,file=heap_pid.hprof PID
  Jprofile 可远程可视化分析
  Elipse memory Analyzer 可视化分析
  jvm内存分配   操作系统给用户进程分配内存空间是虚拟内存，不是物理内存；
  进程在申请内存时，并不是直接分配物理内存的，而是分配一块虚拟空间，到真正堆这块虚拟空间写入数据时才会通过缺页异常（Page Fault）处理机制分配物理内存，也就是我们看到的进程 Res 指标。
  哪怕配置了Xms2G，启动后也不会直接占用 2G 内存，只是 JVM 在启动后会malloc 2G 而已，但实际占用的内存取决于你有没有往这 2G 内存区域中写数据的。</description>
    </item>
    
    <item>
      <title>Hugo&#43;Github个人笔记部署简易教程</title>
      <link>https://dev960.github.io/post/hugo%E7%AC%94%E8%AE%B0%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Sun, 10 Sep 2023 01:37:56 +0800</pubDate>
      
      <guid>https://dev960.github.io/post/hugo%E7%AC%94%E8%AE%B0%E9%83%A8%E7%BD%B2/</guid>
      <description>hugo笔记部署   sudo apt install hugo -y
  hugo new site dcqwiki
  cd dcqwiki
  git git submodule add https://github.com/olOwOlo/hugo-theme-even/tree/v4.0.0https://github.com/olOwOlo/hugo-theme-even themes/even
  hugo server
  本地访问localhost:1313
  编译：hugo
  github创建仓库
  名字和github名字一样
  勾选publi和Readme
  cd public
  git init -b main
  git remote add origin git@github.com:dev960/dev960.github.io.git
  git pull &amp;ndash;rebase origin main
  git add .</description>
    </item>
    
    <item>
      <title>Golang大文件发送提速</title>
      <link>https://dev960.github.io/post/golang%E5%B0%86%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%85%A5%E5%86%85%E5%AD%98/</link>
      <pubDate>Sun, 10 Sep 2023 01:37:56 +2000</pubDate>
      
      <guid>https://dev960.github.io/post/golang%E5%B0%86%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%85%A5%E5%86%85%E5%AD%98/</guid>
      <description>Golang将大文件一次读入内存  利用Slice切片，比每次读取一小块导致频繁Gc
 package main import ( &amp;#34;bufio&amp;#34; &amp;#34;container/list&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;io&amp;#34; &amp;#34;os&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) func main(){ start := time.Now() content, err := ioutil.ReadFile(&amp;#34;d:\\software\\cn_windows_10_consumer_editions_version_21h1_x64_dvd_1baf479d.iso&amp;#34;) if err != nil { fmt.Println(&amp;#34;file read fail&amp;#34;) } fmt.Printf(&amp;#34;read file len :%d, time cost :%v slices: %d\n&amp;#34;, len(content), time.Since(start), len(content)/(8964*20)) step := 8964 * 20 fmt.Println(len(content)%step, step) for i := 0; i &amp;lt; len(content); i += step { if i+step &amp;gt; len(content) { slice := make([]byte, len(content)%step) copy(slice, content[i:i+len(slice)]) fmt.</description>
    </item>
    
  </channel>
</rss>
